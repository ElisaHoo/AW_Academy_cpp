#include "../includes/file_handling.hpp"

int generate_random_value() {
    std::vector<int> v;
    std::random_device rd;  // A seed source for the random number engine
    std::mt19937 gen(rd());  // Mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 1000);
    // Use distrib to transform the random unsigned int
    // generated by gen into an int in [1, 100]
    return distrib(gen);
}

std::vector<DataRegister> generate_register() {
    std::vector<DataRegister> registers;
    for (int i = 1; i <= 10; ++i) {
        DataRegister new_register {i, generate_random_value()};
        registers.push_back(new_register);
    }
    return registers;
}

void generate_devices(std::vector<Device>& devices_db) {
    std::vector<DataRegister> registers = generate_register();
    for (int i = 0; i < 10; ++i) {
        Device new_device {0, false, {registers[i]}};
        devices_db.push_back(new_device);
    }
    Device master_device {1, true, {}};
    devices_db.push_back(master_device);
}

void write_devices_file(std::vector<Device> devices_db) {
    std::ofstream write_devices("devices.csv"); // initialize outpufile
    if (!write_devices.is_open()) {  // Check is it open
        throw std::runtime_error("Couldn't open the file, check that the file exists!");
    }
    write_devices << "ID, is it master?\n";  // Write headlines to the file
    // Loop thrue devices-vector and write the id and boolean of each device
    // (boolean written in letters, not numbers)
    for (auto device : devices_db) {  
        write_devices << device.id << ", " << std::boolalpha << device.is_master << "\n";
    }
    std::cout << "\nDevice list saved successfully!\n";
    write_devices.close();
}

void write_register_file(std::vector<Device> devices_db) {
    std::ofstream write_registers("registers.csv");
    if (!write_registers.is_open()) {
        throw std::runtime_error("Couldn't open the file, check that the file exists!");
    }
    write_registers << "ID register_address value\n";
    for (auto device : devices_db) {
        if (device.id == 0) {  // Include only slave devices
            write_registers 
            << device.id << " " 
            << device.register_db.address << " " 
            << device.register_db.value << "\n";
        }
    }
    std::cout << "\nSlave devices data saved successfully!\n";
    write_registers.close();
}

void clear_failed_cin() {
    if(!std::cin) { // User didn't input number -> cin fails
        std::cin.clear();  // clear cin's failbit
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); //skip bad input
    }
}

std::string get_specific_address() {
    std::cout << "Please enter the slave device register address " 
                    "(number from 1-10), that you want to deal with: ";
    int choice{};
    std::cin >> choice;
    if(!std::cin || choice < 1 || choice > 10) {  // Check that user input is valid
        clear_failed_cin();
        while (true) {  // If input is invalid, keep asking valid input
            std::cout << "Invalid input! Please try again (enter address number from 1 to 10): ";
            std::cin >> choice;
            if(!std::cin || choice < 1 || choice > 10) {
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            } else {
                break;
            }
        }
    }
    std::string choice_str = std::to_string(choice);
    return choice_str;
}

std::string get_specific_register_value(std::string address) {
    // Plan: 1. Read all data into vector value by value 2. Find out the searched value index
    // 3. Return the searched value
    
    std::ifstream read_registers("registers.csv");  // initialize inputfile
    if (!read_registers.is_open()) {  // Check the file can be opened
        throw std::runtime_error("Couldn't open the file, check that the file exists!");
    }

    std::string line{};  // to get the line from a file
    std::string value{};  // to get a single value/"word" from a line
    std::istringstream iss;  // to process string (in this case line)
    std::vector<std::string> container{};  // to store file content
    int counter{0};  // to count vector index
    int index{};  // to store searched index 
    while (!read_registers.eof()) {  // Loop until eof turns true = end of file
        std::getline(read_registers, line);  // Get line from a file and store it to line-variable
        iss.clear();  // Clear out state from previous iteration of the loop
        iss.str(line);  // Copy line-string for iss to stream from
        while (iss.good()) {  // While the state of the string stream is good
            iss >> value;  // Extract a value from line, which iss is set up to stream
            container.push_back(value);  // push the value to container
            counter += 1;  // increase counter
            if (value == address) {  // if address-value is found
                index = counter;  // Get searched index (it's +1 to the address value index)
            }
        }
    }
    read_registers.close();
    return container[index]; // Return the searched value
}

std::vector<std::string> push_file_data_into_vector() {
    std::vector<std::string> file_data{};
    std::string line{};
    std::string v{};
    std::istringstream iss{};
    std::ifstream read_file("registers.csv");
    // Read line by line and push it to vector
    while (std::getline(read_file, line)) {
        iss.clear();
        iss.str(line);
        while (iss.good()) {
            iss >> v;
            file_data.push_back(v);
        }
    }
    read_file.close();
    return file_data;
}

std::vector<std::string> modify_specific_value(
        std::vector<std::string> file_data, 
        std::string address, 
        std::string new_value) {
    // Get the index of the address that is wanted to modify (value's index is + 1)
    auto match = std::find(file_data.begin(), file_data.end(), address);
    int index = std::distance(file_data.begin(), match);
    // Modify the value
    file_data[index+1] = new_value;
    return file_data;  // return modified vector
}

void overwrite_file_with_modified_data(std::vector<std::string> file_data) {
    // Write modified vector values to file (overwrite old data)
    std::ofstream write_registers("registers.csv");
    if (!write_registers.is_open()) {
        throw std::runtime_error("Couldn't open the file, check that the file exists!");
    }
    for (int i = 0; i < file_data.size(); ++i) {
        if (i % 3 == 0 && i != 0) {  // Get new line after every third value
            write_registers << "\n";
        }
        write_registers << file_data[i] << " ";
    }
    write_registers.close();
}