#include "../includes/sensor.h"

long int generate_timestamp() {
    // Not real time stamp, just for simulation purpose
    std::random_device rd;  // A seed source for the random number engine
    std::mt19937 gen(rd());  // Mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1000, 9999);
    // Use distrib to transform the random unsigned int
    // generated by gen into an int in [1, 100]
    int time{distrib(gen)};
    return (time);
}

std::string generate_id() {
    char alphabet[4] = {'a', 'b', 'c', 'd'};
    std::string id{};
    // Makes 2 character long random string using alphabet-array's characters
    for (int i = 0; i < 2; ++i) {
        id += alphabet[rand() % 4]; 
    }
    return id;
}

float generate_sensor_value() {
    std::random_device rd;  // A seed source for the random number engine
    std::mt19937 gen(rd());  // Mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 100);
    // Use distrib to transform the random unsigned int
    // generated by gen into an int in [1, 100]
    int int_data{distrib(gen)};
    float float_data{static_cast <float> (int_data)};
    return (float_data / 1000);
}

void generate_sensor_data(SensorData sensor_data) {
    // Generate 30 sensor_data -sturcts and push them to a sensor_data_list -vector
    for (int i = 0; i < 30; ++i) {
        sensor_data.timestamp = generate_timestamp();
        sensor_data.sensor_id = generate_id();
        sensor_data.sensor_value = generate_sensor_value();
        sensor_data_list.push_back(sensor_data);
    }
    // Print values out
    std::cout << "Raw sensor data: \n";
    for (int i = 0; i < sensor_data_list.size(); i++) {
        std::cout << sensor_data_list[i].sensor_id << " " 
                  << sensor_data_list[i].timestamp << " " 
                  << sensor_data_list[i].sensor_value << "\n";
    }
}

std::vector<SensorData> filter_specified_sensor_data(SensorData sensor_data, std::string specified_id) {
    std::vector<SensorData> specified_sensor_data_list;
    // Loop through sensor_data_list and when find the specified sensor id (in this simulation it is 5th 
    // struct element id), push this struct to the vector to be returned
    for (int i = 0; i < sensor_data_list.size(); ++i) {
        if (specified_id == sensor_data_list[i].sensor_id) {
            sensor_data.sensor_id = sensor_data_list[i].sensor_id; 
            sensor_data.timestamp = sensor_data_list[i].timestamp;
            sensor_data.sensor_value = sensor_data_list[i].sensor_value;
            specified_sensor_data_list.push_back(sensor_data);
        }
    }
    return specified_sensor_data_list;
}

bool compare_timestamps(const SensorData& first, const SensorData& second) 
                       {return first.timestamp < second.timestamp;}

void sort_data_based_on_timestamp(std::vector<SensorData>& specified_sensor_data_list) {
    std::sort(specified_sensor_data_list.begin(), specified_sensor_data_list.end(), compare_timestamps);
}

void print_data(std::vector<SensorData> data_vector) {
    // Function to print data out from vector
    for (int i = 0; i < data_vector.size(); i++) {
        std::cout << data_vector[i].sensor_id << " " 
                  << data_vector[i].timestamp << " " 
                  << data_vector[i].sensor_value << "\n";
    }
}

void detect_outliers() {
    // Calculate sum of all sensor values
    float value_sum{};
    for (int i = 0; i < sensor_data_list.size(); ++i) {
        value_sum += sensor_data_list[i].sensor_value;
    }
    // Get average of sensor values
    float average{value_sum / sensor_data_list.size()};
    std::cout << "\nAverage sensor data value: " << average << "\n";

    // Print out sensor data if value is 0.03 above or below the average
    std::cout << "\nSensor data that deviates by 0.03 over or under average:\n";
    for (int i = 0; i < sensor_data_list.size(); ++i) {
        if ((sensor_data_list[i].sensor_value > (average + 0.03)) 
            || (sensor_data_list[i].sensor_value < (average - 0.03))) {
            std::cout << sensor_data_list[i].sensor_id << " " 
            << sensor_data_list[i].timestamp << " " 
            << sensor_data_list[i].sensor_value << "\n";
        }
    }
    std::cout << "\n";
}

void find_sensor_with_highest_frequency_of_readings(std::vector<SensorData>& v, SensorData) {
    int freq{};  // to get the frequency
    std::vector<std::string> most_freq_id{};  //vector to collect the ids if there are more than one match
    for (int i = 0; i < v.size(); ++i) {  // Loops the vector id by id
        int count{0};
        for (int j = i + 1; j < v.size(); ++j) {  // Checks how many times v[i] has occured
            if (v[j].sensor_id == v[i].sensor_id) {
                count++;  // counter increases if same id is found
            }
        }
        // If counter value is greater or than frequency most_freq_id is first cleared and then updated
        if (count > freq) {
            most_freq_id.clear();
            most_freq_id.push_back(v[i].sensor_id);
            freq = count;
        // If counter value is same than frequency most_freq is only updated
        } else if (count == freq) {
            most_freq_id.push_back(v[i].sensor_id);
        }
    }
    // Print the ids out depending on how many ids have been found
    if (most_freq_id.size() == 1) {
        std::cout << "The sensor that has the highest frequency of readings is " << most_freq_id[0] << "\n";
    } else if (most_freq_id.size() > 1) {
        std::cout << "The sensors that have the highest frequency of readings are\n";
        for (int i = 0; i < most_freq_id.size(); ++i) {
            std::cout << most_freq_id[i] << " ";
        }
        std::cout << "\n";
    }
}